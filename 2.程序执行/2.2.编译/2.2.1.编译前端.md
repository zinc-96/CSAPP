# 2.2.1.编译前端

分析过程也被称为**编译前端**，包括：词法分析、语法分析、语义分析、中间代码生成。将源程序分解为多个组成要素，增加语法结构，**理解代码**。通过**符号表**配合，将源程序表达为**中间表示**（中间语言）。

​![image](assets/image-20240529133854-zk78bde.png)​

## 词法分析

* 词法分析器从输入中读取字符，并将它们组成词法单元对象
* 词素是构成一个词法单元的字符序列
* 词法分析器使得语法分析器不需要考虑词素的表示方式

词法分析的通常做法：

* 剔除空白和注释

  * 大部分语言允许词法单元出现任意数量的空白，需要进行修正
* 预读

  * 在分析词法单元时，词法分析器需要先读入一些字符。比如遇到字符`>`​，预读下一个字符是否是`=`​，形成词法单元“大于等于”。
  * 预先读取的实现方式是不断将字符取出或者放回输入缓冲区
* 常量

  * 在表达式中，允许出现数字的地方可能出现任意长度的整型常量，词法分析器将多个数位组成整数，并创建一个整型终结符。例如：`31+28+59`​可以被表示为`<num, 31> <+> <num, 28> <+> <num, 59>`​。
* 关键字和标识符

  * 程序设计语言预先定义关键字，用来表达某种构造。程序会定义一些标识符，如`int a=1`​。语法分析器将所有标识符当作统一的终结符号`id`​进行表示。比如`count = count + increment`​可以被表示为`<id, count> <=> <id, count > <+> <id, increment>`​。

实例：`if (a >= 3 + 40 * (12 -1))`​的词法分析过程

1. 剔除空格，识别出标识符`i`​，触发**预读**继续读入`f`​，继续读入`(`​
2. 将`(`​放回缓冲区，查表可知`if`​是关键字
3. 继续读入`a`​，根据**预读**可以标记该字符为标识符
4. 继续读入`>`​，触发**预读**逻辑，读取`=`​，标记为大于等于
5. 识别数字`3`​，触发常量分析，读入`+`​，不是数值，将`+`​放回缓冲区
6. 识别`+`​运算符，预读查看是否是`++`​
7. 继续读入`4`​，触发常量分析，读入`0`​，继续触发常量分析读入`*`​
8. 继续读入`(`​，标记为符号，以此类推
9. 最后得到符号表：  
    ​![image](assets/image-20240529135216-7pykfke.png)​

### 符号表

符合表是一种保存有关源程序构造信息的数据结构，由词法分析创建，在分析阶段逐步构造，在综合阶段用于目标代码生成。

符号表的每个条目是一个键值对关系，表示与一个标识符有关的类别，如字符串、类型、地址等。

​![image](assets/image-20240529135941-ea446n5.png)​

‍

#### 作用域

由于程序的不同部分可能多次声明同名标识符（如一些常用变量名称或子类覆盖父类中的相应方法），因此我们需要划分符号表的作用域，每个作用域设置独立的符号表。

作用域：程序中不同的逻辑分区，表达符号作用范围。

例如：声明`x,y,w,z`​四个标识符，下标表示行号，如`x1`​代表行1中声明的`x`​，w0表示在这个代码段之前已声明的变量。

​![image](assets/image-20240529142318-wvka3nr.png)​

符号表之间形成链接关系，B1代表第一行开始的语句块，B2代表第二行开始的语句块。

编译前端在分析第1行时，符号表指针指向B1，此时`x,y`​对应第1行代码定义的变量；分析第2-4行时，符号表指针指向B2，此时`w,y,z`​对应第2行代码定义的变量。

​![image](assets/image-20240529142430-v3jcm4y.png)​

符号表记录了程序所使用的符号及作用域，形成分区字典。经过词法分析，程序变成token序列。

## 语法分析

语法分析是**使用文法生成一个终结符号串**的过程，关键在于为输入字符串找到适应文法，并表达文法。经过语法分析，输入的源程序有了文法结构，进而可以分析语义。

对比自然语言：词法分析 = 分词，语法分析 = 主谓宾

### 文法

文法描述了程序设计语言构造的**层次化语法结构**，基本思想：从一组特殊的**初始符号**出发，不断应用一些**产生式规则**，生成一组新的符号组合。文法是字符推理的过程，也称形式文法。

例如，`if (expression) statement else statement`​中，使用`stmt`​表示语句，`expr`​表示表达式，该构造规则可以表示为`stmt → if (expr) stmt else stmt`​，其中`→`​读作“可具有以下形式”，`if`​、`else`​、括号是终结符，`stmt`​和`expr`​是非终结符。

#### 上下文无关文法

上下文无关文法是形式文法的一种，通过符号与规则，定义一个语言。上下文无关是指在G中，V可以被任意字符串替换。上下文无关文法简化了文法中规则的表达，无需考虑规则依赖关系，几乎所有程序设计语言都可以由上下文无关文法表示。

​`G = (V, Σ, R, S)`​

* V：一个**非终结符号**的有限集合，句子中的占位符
* Σ：一个**终结符号**的有限集合，构成句子的实质内容
* R：从V到 (V∪Σ)* 的关系，构成文法**规则**
* S：初始变量，用来表示句子开始的非终结符号

#### 语法分析树

语法分析树用结构展现了从文法的开始符号推导出相应符号串的过程。

非终结符A的一个产生式`A→XYZ`​，则存在它的一种语法分析树：

​![image](assets/image-20240529163349-4qsc6bg.png)​

语法分析是使用**文法**生成一个终结符号串的过程，分为“自顶向下”和“自底向上”两种：

* 自顶向下：从根节点开始构造语法树，逐步构造出叶子节点
* 自底向上：从叶节点开始逐步构造出根节点

例如`9-5+2`​的语法树：

​![image](assets/image-20240529163952-ghcifwc.png)​

> 根据如下文法，分析输入字符串`for (;expr;expr) other`​的结构。
>
> ​![image](assets/image-20240529164418-axoz9he.png)​
>
> ​![image](assets/image-20240529164518-q94ueys.png)​
>
> ​![image](assets/image-20240529164538-qg0tmzq.png)​
>
> ​![image](assets/image-20240529164554-el7uzif.png)​
>
> ​![image](assets/image-20240529164603-ilc4jo9.png)​
>
> ​![image](assets/image-20240529164621-g6sv0n5.png)​
>
> ​![image](assets/image-20240529164638-n18fgv7.png)​
>
> ​![image](assets/image-20240529164653-zunlfvh.png)​

一般来说，为一个非终结符号选择产生式是一个“尝试并犯错”的过程，需要在发现产生式不合适时进行回溯。**递归下降分析法**是一种常用的**自顶向下**的语法分析方法。

> 基于下面的文法对`aab`​是否**符合文法**进行分析，大写为非终结符，小写为终结符。
>
> ​![image](assets/image-20240529165036-2hugiag.png)​
>
> ​![01](assets/01-20240529183405-8tbx3e0.jpg)​
>
> ​![02](assets/02-20240529183405-u5fxg95.jpg)​
>
> ​![03](assets/03-20240529183405-og0qzh8.jpg)​
>
> ​![04](assets/04-20240529183405-chcvg6k.jpg)​
>
> ​![05](assets/05-20240529183405-z4udupm.jpg)​
>
> ​![06](assets/06-20240529183405-ixse46u.jpg)​
>
> ​![07](assets/07-20240529183405-4sawuci.jpg)​
>
> ​![08](assets/08-20240529183405-h8px8ak.jpg)​
>
> ​![09](assets/09-20240529183405-ub5aa2v.jpg)​
>
> ​![10](assets/10-20240529183405-p6ban7k.jpg)​
>
> ​![11](assets/11-20240529183405-7xs6812.jpg)​

## 中间代码生成

**中间语言**：一种面向语法、易于翻译成目标程序的内部代码表示，可理解性介于源语言和目标语言之间，对源语言提供的丰富表达进行归一，形成统一模式，也叫**中间代码**。

作用：

* 为了语法统一，便于分析和转换
* 为了产生高质量的程序，将源语言翻译成中间代码，之后对其进行优化，再翻译成目标代码

常用的中间代码有：

* 逆波兰表示：后缀式
* 图表示法：抽象语法树、DAG图
* 四元式
* 三元式

### 逆波兰式（后缀式）

将运算符置于其运算对象之后，操作数在前，运算符在后，运算是按照运算符出现的顺序进行，无需括号指示顺序。

​`A+B*(C-D)+E/(C-D)`​的逆波兰表示为`ABCD-*+ECD-/+`​

​`(a<0∧b>3)∨(e∧x>y)`​的逆波兰表示为`a0<b3>∧exy>∧∨`​

### 抽象语法树

去掉不必要信息，获得更高效的源程序中间表示，内部结点代表操作符，叶子节点代表操作数。

​![image](assets/image-20240529195905-8j56lp0.png)​

### DAG

**DAG（Directed Acyclic Graph，无循环有向图）** ：与抽象语法树相似，但DAG中公共子表达式结点可有多个父结点

​![image](assets/image-20240529200158-86i7tu8.png)​

### 三地址码

最基本的形式：`x = y op z`​，其中x、y、z是名字、常数或编译时产生的临时变量，op代表运算符号，每个语句的右边只有一个运算符。

比如`x + y * z`​ 可以翻译为：

```C
T1 = y * z
T2 = x + T1
```

T1、T2为编译时产生的临时变量。

三地址码也可以看成是抽象语法树和DAG图的一种线性表示

​![image](assets/image-20240529200408-c96ym2u.png)​

​![image](assets/image-20240529200418-ofs1wgm.png)​

​![image](assets/image-20240529200441-g31h2in.png)​

### 四元式

一种“三地址码”的等价表示，一般形式为：`(op, arg1, arg2, result)`​，每个四元式只能有一个运算符，一个复杂的表达式由多个四元式构成。

​![image](assets/image-20240529200528-svnpx1n.png)​

### 三元式

一种“三地址码”的等价表示，一般形式为: `(i)(op, arg1, arg2)`​，`(i)`​是三元式的编号，也代表了运算结果，`arg`​可以是某个三元式的序号`(i)`​。

​![image](assets/image-20240529201423-6qypuxn.png)​

三元式和四元式的比较：

* 相同点

  * 按照表达式的实际运算顺序出现，信息表达当量相同
  * 对同一表达式，三元式和四元式个数一般是相同的
* 不同点

  * 三元式没有result字段，不需要临时变量，存储空间占用少
  * 代码优化阶段可能需要频繁移动三地址码语句的位置，四元式具有临时变量，更加灵活

‍
